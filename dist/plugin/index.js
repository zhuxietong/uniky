import * as fs from 'fs';
import fs__default from 'fs';
import * as path2 from 'path';
import path2__default from 'path';

// src/plugin/pages.defined.ts
function stripJsonComments(jsonString) {
  let result = "";
  let inString = false;
  let inSingleLineComment = false;
  let inMultiLineComment = false;
  let escapeNext = false;
  for (let i = 0; i < jsonString.length; i++) {
    const char = jsonString[i];
    const nextChar = jsonString[i + 1];
    if (escapeNext) {
      if (inString) {
        result += char;
      }
      escapeNext = false;
      continue;
    }
    if (char === "\\" && inString) {
      result += char;
      escapeNext = true;
      continue;
    }
    if (char === '"' && !inSingleLineComment && !inMultiLineComment) {
      inString = !inString;
      result += char;
      continue;
    }
    if (inString) {
      result += char;
      continue;
    }
    if (inMultiLineComment) {
      if (char === "*" && nextChar === "/") {
        inMultiLineComment = false;
        i++;
      }
      continue;
    }
    if (inSingleLineComment) {
      if (char === "\n" || char === "\r") {
        inSingleLineComment = false;
        result += char;
      }
      continue;
    }
    if (char === "/") {
      if (nextChar === "/") {
        inSingleLineComment = true;
        i++;
        continue;
      }
      if (nextChar === "*") {
        inMultiLineComment = true;
        i++;
        continue;
      }
    }
    result += char;
  }
  return result;
}
function extractPagePaths(pagesJson) {
  const pagePaths = [];
  if (pagesJson.pages && Array.isArray(pagesJson.pages)) {
    pagesJson.pages.forEach((page) => {
      if (page.path) {
        pagePaths.push(page.path);
      }
    });
  }
  if (pagesJson.subPackages && Array.isArray(pagesJson.subPackages)) {
    pagesJson.subPackages.forEach((subPackage) => {
      const root = subPackage.root;
      if (subPackage.pages && Array.isArray(subPackage.pages)) {
        subPackage.pages.forEach((page) => {
          if (page.path) {
            const fullPath = `${root}/${page.path}`.replace(/\/+/g, "/");
            pagePaths.push(fullPath);
          }
        });
      }
    });
  }
  return pagePaths;
}
function generateTypeScriptCode(pagePaths) {
  const pagesArray = pagePaths.map((p) => `"${p}"`).join(", ");
  return `// Auto-generated by vite-plugin-pages-defined
// Do not edit this file manually

export const _Pages = [${pagesArray}] as const;
export type _PagePath = typeof _Pages[number];

type RouteFunction = (path: _PagePath, options?: { query?: Record<string, any>, json?: Record<string, any> }) => void;

interface ToRouteInterface {
  navigate: RouteFunction;
  redirect: RouteFunction;
  switchTab: RouteFunction;
  reLaunch: RouteFunction;
  back: (delta?: number) => void;
}

const buildUrl = (path: string, query?: Record<string, any>, json?: Record<string, any>): string => {
  const fullPath = path.startsWith('/') ? path : \`/\${path}\`;
  const params: string[] = [];
  
  if (query && Object.keys(query).length > 0) {
    Object.entries(query).forEach(([key, value]) => {
      params.push(\`\${encodeURIComponent(key)}=\${encodeURIComponent(String(value))}\`);
    });
  }
  
  if (json && Object.keys(json).length > 0) {
    const jsonStr = JSON.stringify(json);
    params.push(\`json=\${encodeURIComponent(jsonStr)}\`);
  }
  
  return params.length > 0 ? \`\${fullPath}?\${params.join('&')}\` : fullPath;
};

const ToRoute: ToRouteInterface = {
  navigate: (path, options) => {
    const url = buildUrl(path, options?.query, options?.json);
    uni.navigateTo({ url });
  },
  redirect: (path, options) => {
    const url = buildUrl(path, options?.query, options?.json);
    uni.redirectTo({ url });
  },
  switchTab: (path, options) => {
    const url = buildUrl(path, options?.query, options?.json);
    uni.switchTab({ url });
  },
  reLaunch: (path, options) => {
    const url = buildUrl(path, options?.query, options?.json);
    uni.reLaunch({ url });
  },
  back: (delta = 1) => {
    uni.navigateBack({ delta });
  }
};

export const _To = ToRoute;
`;
}
function generatePagesFile(srcDir, outputPath) {
  try {
    const pagesJsonPath = path2__default.resolve(srcDir, "pages.json");
    if (!fs__default.existsSync(pagesJsonPath)) {
      console.warn("[pages-defined] pages.json not found");
      return;
    }
    const pagesJsonContent = fs__default.readFileSync(pagesJsonPath, "utf-8");
    const cleanedJson = stripJsonComments(pagesJsonContent);
    const pagesJson = JSON.parse(cleanedJson);
    const pagePaths = extractPagePaths(pagesJson);
    const code = generateTypeScriptCode(pagePaths);
    const outputDir = path2__default.dirname(outputPath);
    if (!fs__default.existsSync(outputDir)) {
      fs__default.mkdirSync(outputDir, { recursive: true });
    }
    fs__default.writeFileSync(outputPath, code, "utf-8");
    console.log(`[pages-defined] Generated ${outputPath} with ${pagePaths.length} pages`);
  } catch (error) {
    console.error("[pages-defined] Error generating pages.ts:", error);
  }
}
function pagesDefinedPlugin() {
  let srcDir;
  let outputPath;
  return {
    name: "vite-plugin-pages-defined",
    configResolved(config) {
      srcDir = path2__default.resolve(config.root, "src");
      outputPath = path2__default.resolve(srcDir, "autoGen/global/pages.ts");
    },
    buildStart() {
      generatePagesFile(srcDir, outputPath);
    },
    configureServer(server) {
      const pagesJsonPath = path2__default.resolve(srcDir, "pages.json");
      server.watcher.add(pagesJsonPath);
      server.watcher.on("change", (file) => {
        if (file === pagesJsonPath) {
          console.log("[pages-defined] pages.json changed, regenerating pages.ts...");
          generatePagesFile(srcDir, outputPath);
        }
      });
      generatePagesFile(srcDir, outputPath);
    }
  };
}
function globalDefinedPlugin() {
  const globalDir = "src/autoGen/global";
  const globalDtsPath = "src/autoGen/global.d.ts";
  const installTsPath = "src/autoGen/global.install.ts";
  function getTsFiles(dir) {
    const files = [];
    if (!fs.existsSync(dir)) {
      return files;
    }
    const entries = fs.readdirSync(dir, { withFileTypes: true });
    for (const entry of entries) {
      const fullPath = path2.join(dir, entry.name);
      if (entry.isDirectory()) {
        files.push(...getTsFiles(fullPath));
      } else if (entry.isFile() && entry.name.endsWith(".ts") && !entry.name.endsWith(".d.ts") && entry.name !== "global.install.ts") {
        files.push(fullPath);
      }
    }
    return files;
  }
  function parseExports(filePath) {
    const content = fs.readFileSync(filePath, "utf-8");
    const exports$1 = [];
    const defaultExportRegex = /export\s+default\s+(function|class|const|let|var)?\s*([a-zA-Z_$][a-zA-Z0-9_$]*)?/g;
    let match;
    while ((match = defaultExportRegex.exec(content)) !== null) {
      if (match[2]) {
        exports$1.push({
          name: match[2],
          type: match[1] || "const",
          isDefault: true,
          filePath
        });
      }
    }
    const functionRegex = /export\s+(?:async\s+)?function\s+([a-zA-Z_$][a-zA-Z0-9_$]*)/g;
    while ((match = functionRegex.exec(content)) !== null) {
      exports$1.push({
        name: match[1],
        type: "function",
        isDefault: false,
        filePath
      });
    }
    const varRegex = /export\s+(?:const|let|var)\s+([a-zA-Z_$][a-zA-Z0-9_$]*)/g;
    while ((match = varRegex.exec(content)) !== null) {
      exports$1.push({
        name: match[1],
        type: "const",
        isDefault: false,
        filePath
      });
    }
    const classRegex = /export\s+(?:abstract\s+)?class\s+([a-zA-Z_$][a-zA-Z0-9_$]*)/g;
    while ((match = classRegex.exec(content)) !== null) {
      exports$1.push({
        name: match[1],
        type: "class",
        isDefault: false,
        filePath
      });
    }
    const interfaceRegex = /export\s+interface\s+([a-zA-Z_$][a-zA-Z0-9_$]*)/g;
    while ((match = interfaceRegex.exec(content)) !== null) {
      exports$1.push({
        name: match[1],
        type: "interface",
        isDefault: false,
        filePath
      });
    }
    const typeRegex = /export\s+type\s+([a-zA-Z_$][a-zA-Z0-9_$]*)/g;
    while ((match = typeRegex.exec(content)) !== null) {
      exports$1.push({
        name: match[1],
        type: "type",
        isDefault: false,
        filePath
      });
    }
    const enumRegex = /export\s+(?:const\s+)?enum\s+([a-zA-Z_$][a-zA-Z0-9_$]*)/g;
    while ((match = enumRegex.exec(content)) !== null) {
      exports$1.push({
        name: match[1],
        type: "enum",
        isDefault: false,
        filePath
      });
    }
    const namedExportRegex = /export\s*{([^}]+)}/g;
    while ((match = namedExportRegex.exec(content)) !== null) {
      const names = match[1].split(",").map((n) => n.trim().split(/\s+as\s+/)[0].trim());
      for (const name of names) {
        if (name) {
          exports$1.push({
            name,
            type: "const",
            isDefault: false,
            filePath
          });
        }
      }
    }
    return exports$1;
  }
  function generateGlobalDts(allExports) {
    const imports = /* @__PURE__ */ new Map();
    for (const exp of allExports) {
      const relativePath = path2.relative("src/autoGen", exp.filePath).replace(/\\/g, "/").replace(/\.ts$/, "");
      if (!imports.has(relativePath)) {
        imports.set(relativePath, /* @__PURE__ */ new Set());
      }
      if (!exp.isDefault) {
        imports.get(relativePath).add(exp.name);
      }
    }
    let content = "// \u81EA\u52A8\u751F\u6210\u7684\u5168\u5C40\u7C7B\u578B\u5B9A\u4E49\u6587\u4EF6\n";
    content += "// \u8BF7\u52FF\u624B\u52A8\u4FEE\u6539\n\n";
    for (const [filePath, names] of imports) {
      if (names.size > 0) {
        content += `import type { ${Array.from(names).join(", ")} } from './${filePath}';
`;
      }
    }
    content += "\n";
    content += "declare global {\n";
    const globalItems = allExports.filter((exp) => !exp.isDefault && exp.type !== "interface" && exp.type !== "type");
    if (globalItems.length > 0) {
      for (const exp of globalItems) {
        if (exp.type === "function") {
          content += `  const ${exp.name}: typeof import('./${path2.relative("src/autoGen", exp.filePath).replace(/\\/g, "/").replace(/\.ts$/, "")}').${exp.name};
`;
        } else if (exp.type === "const") {
          content += `  const ${exp.name}: typeof import('./${path2.relative("src/autoGen", exp.filePath).replace(/\\/g, "/").replace(/\.ts$/, "")}').${exp.name};
`;
        } else if (exp.type === "class") {
          content += `  const ${exp.name}: typeof import('./${path2.relative("src/autoGen", exp.filePath).replace(/\\/g, "/").replace(/\.ts$/, "")}').${exp.name};
`;
        }
      }
    }
    content += "}\n\n";
    content += "export {};\n";
    return content;
  }
  function generateInstallTs(allExports) {
    const imports = /* @__PURE__ */ new Map();
    for (const exp of allExports) {
      const relativePath = "./global/" + path2.relative(path2.join("src", "autoGen", "global"), exp.filePath).replace(/\\/g, "/").replace(/\.ts$/, "");
      if (!imports.has(relativePath)) {
        imports.set(relativePath, { names: /* @__PURE__ */ new Set(), hasDefault: false });
      }
      const importInfo = imports.get(relativePath);
      if (exp.isDefault) {
        importInfo.hasDefault = true;
        importInfo.defaultName = exp.name;
      } else if (exp.type !== "interface" && exp.type !== "type") {
        importInfo.names.add(exp.name);
      }
    }
    let content = "// \u81EA\u52A8\u751F\u6210\u7684\u5168\u5C40\u5B89\u88C5\u6587\u4EF6\n";
    content += "// \u8BF7\u52FF\u624B\u52A8\u4FEE\u6539\n\n";
    for (const [filePath, info] of imports) {
      if (info.hasDefault && info.names.size > 0) {
        content += `import ${info.defaultName}, { ${Array.from(info.names).join(", ")} } from '${filePath}';
`;
      } else if (info.hasDefault) {
        content += `import ${info.defaultName} from '${filePath}';
`;
      } else if (info.names.size > 0) {
        content += `import { ${Array.from(info.names).join(", ")} } from '${filePath}';
`;
      }
    }
    content += "\n";
    content += "/**\n";
    content += " * \u5B89\u88C5\u5168\u5C40\u5B9A\u4E49\n";
    content += " * \u5728 main.ts \u4E2D\u8C03\u7528\u6B64\u51FD\u6570\u4EE5\u6CE8\u518C\u5168\u5C40\u53D8\u91CF\n";
    content += " */\n";
    content += "export function installGlobals() {\n";
    const globalItems = allExports.filter((exp) => exp.type !== "interface" && exp.type !== "type");
    for (const exp of globalItems) {
      const name = exp.isDefault ? imports.get("./global/" + path2.relative(path2.join("src", "autoGen", "global"), exp.filePath).replace(/\\/g, "/").replace(/\.ts$/, ""))?.defaultName || exp.name : exp.name;
      content += `  (globalThis as any).${exp.name} = ${name};
`;
    }
    content += "}\n";
    return content;
  }
  function generate() {
    try {
      const tsFiles = getTsFiles(globalDir);
      if (tsFiles.length === 0) {
        console.log("[globalDefined] \u672A\u627E\u5230\u4EFB\u4F55 TypeScript \u6587\u4EF6");
        return;
      }
      const allExports = [];
      for (const file of tsFiles) {
        const exports$1 = parseExports(file);
        allExports.push(...exports$1);
      }
      if (allExports.length === 0) {
        console.log("[globalDefined] \u672A\u627E\u5230\u4EFB\u4F55\u5BFC\u51FA");
        return;
      }
      const dtsContent = generateGlobalDts(allExports);
      fs.writeFileSync(globalDtsPath, dtsContent, "utf-8");
      console.log(`[globalDefined] \u5DF2\u751F\u6210 ${globalDtsPath}`);
      const installContent = generateInstallTs(allExports);
      fs.writeFileSync(installTsPath, installContent, "utf-8");
      console.log(`[globalDefined] \u5DF2\u751F\u6210 ${installTsPath}`);
      console.log(`[globalDefined] \u5171\u5904\u7406 ${tsFiles.length} \u4E2A\u6587\u4EF6\uFF0C${allExports.length} \u4E2A\u5BFC\u51FA`);
    } catch (error) {
      console.error("[globalDefined] \u751F\u6210\u5931\u8D25:", error);
    }
  }
  return {
    name: "vite-plugin-global-defined",
    buildStart() {
      generate();
    },
    configureServer(server) {
      server.watcher.add(globalDir);
      server.watcher.on("change", (file) => {
        if (file.includes("src/autoGen/global") && file.endsWith(".ts") && !file.endsWith(".d.ts") && !file.includes("global.install.ts")) {
          console.log(`[globalDefined] \u68C0\u6D4B\u5230\u6587\u4EF6\u53D8\u5316: ${file}`);
          generate();
        }
      });
      server.watcher.on("add", (file) => {
        if (file.includes("src/autoGen/global") && file.endsWith(".ts") && !file.endsWith(".d.ts") && !file.includes("global.install.ts")) {
          console.log(`[globalDefined] \u68C0\u6D4B\u5230\u65B0\u6587\u4EF6: ${file}`);
          generate();
        }
      });
      server.watcher.on("unlink", (file) => {
        if (file.includes("src/autoGen/global") && file.endsWith(".ts") && !file.endsWith(".d.ts") && !file.includes("global.install.ts")) {
          console.log(`[globalDefined] \u68C0\u6D4B\u5230\u6587\u4EF6\u5220\u9664: ${file}`);
          generate();
        }
      });
    }
  };
}

// src/plugin/index.ts
function unikyPlugin(options = {}) {
  const { enablePages = true, enableGlobal = true } = options;
  const plugins = [];
  if (enablePages) {
    plugins.push(pagesDefinedPlugin());
  }
  if (enableGlobal) {
    plugins.push(globalDefinedPlugin());
  }
  return plugins;
}
var plugin_default = unikyPlugin;

export { plugin_default as default, globalDefinedPlugin, pagesDefinedPlugin, unikyPlugin };
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map